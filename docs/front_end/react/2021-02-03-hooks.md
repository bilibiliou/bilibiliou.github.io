# Hooks cheat sheet

## usePersistCallback

usePersistCallback 不是React原生所支持的hook, 是我们自己基于原生hook进行封装的
usePersistCallback 能解决什么问题呢？

举一个例子

```ts
// 子组件通过父级传递一个onClick函数下来，
// 绑定在组件内的节点上
const ChildComponent: React.FC<{
  onClick: () => void;
}> = React.memo(({ onClick }) => {
  console.log("Child component renders");
  return <button onClick={onClick}>Increment count</button>;
});

// 有两种不一样的写法，一种使用useCallback vs usePersistCallback
const ParentComponentWithUseCallback: React.FC = () => {
  const [count, setCount] = useState(0);

  // 如果每当 count 加1
  // 由于count被改变了，导致整个函数被重新定义了一次
  // incrementCount 这个函数会被重新定义一遍
  // 由于 incrementCount 是作为 ChildComponent 的Prop 传入下去的
  // 这样会导致 ChildComponent 被触发重渲染
  const incrementCount = useCallback(() => {
    setCount(count + 1);
  }, [count]);

  return (
    <div className="section">
      <h3>useCallback</h3>
      <h5>{`Count: ${count}`}</h5>
      <ChildComponent onClick={incrementCount} />
    </div>
  );
};

const ParentComponentWithUsePersistCallback: React.FC = () => {
  const [count, setCount] = useState(0);
  // usePersistCallback 当count发生改变的时候，内部的函数会刷新
  // 但是 incrementCount 引用不会被重置
  // 这样就不会导致子组件props发生变化，触发重渲染
  const incrementCount = usePersistCallback(() => {
    setCount(count + 1);
  });

  return (
    <div className="section">
      <h3>usePersistCallback</h3>
      <h5>{`Count: ${count}`}</h5>
      <ChildComponent onClick={incrementCount} />
    </div>
  );
};
```

usePersistCallback 类似于 React 原生的 useCallback hook，但是区别在于，useCallback 返回的函数引用会随着依赖的变化而变化，但是 usePersistCallback 的函数引用永久不会变化，但是却可以获取到所其“依赖”的最新值。

### 实现

```ts
import { useRef, useCallback } from "react";

function usePersistCallback<T extends (...args: any[]) => any>(fn?: T) {
  const ref = useRef<T>();

  ref.current = fn;

  return useCallback<T>(
    // @ts-ignore
    (...args) => {
      const fn = ref.current;
      return fn && fn(...args);
    },
    [ref]
  );
}
```

## 滚动缓存

SPA 页面中，根据用户访问的路由，记录用户每个页面滚动的距离，当用户来回切换页面的时候，会根据缓存重置为之前的浏览位置


### 实现

```ts
export const useScrollRestoration = (() => {

  const previousPositions: Record<string, number> = {};

  return function <T extends HTMLElement> (key?: string) {

    const container = useRef<T>(null);

    useEffect(() => {
      // 根据页面的路径作为标识符，记录缓存
      const restoreKey = key || location.pathname;
      // 每次页面 DidMount 的时候，重置浏览位置
      if (container.current && previousPositions[restoreKey] > 0) {
        container.current.scrollTop = previousPositions[restoreKey];
      }

      return () => {
        // 离开页面的时候，缓存当前的位置，待下一次进来的时候，依据缓存进行重置
        previousPositions[restoreKey] = container.current?.scrollTop || 0;
      };
    }, []);

    return container;
  };
})();
```

### 使用

```tsx
const container = useScrollRestoration<HTMLDivElement>();

<!-- 每个页面的根节点 -->
<div className="page_root" ref={container}>
  ...
</div>
```

## 开关

用于Boolean 变量的控制，可以通过 toggle 触发切换，也可以指定一个值

### 实现

```ts
function useBoolean(init: boolean): [boolean, (v?: boolean) => void] {
  const [value, setValue] = useState(init);

  const toggle = (v = !value) => setValue(typeof v === 'boolean' ? v : !value);

  return [value, toggle];
}
```

### 使用

```tsx
// 初始值为true, 调用hook后返回当前值和切换函数
const [value, toggleValue] = useBoolean(true);
```

## 模拟vue watch 方法

实现 Vue watch 的方法，首次不会执行，但是当被依赖的内容改变的时候就会执行

### 实现

```tsx
const useDidMountEffect = (func: Function, deps: Array<any>) => {
  const didMount = useRef(false);

  useEffect(() => {
    if (didMount.current) {
      func && func();
    } else {
      didMount.current = true;
    }
  }, deps);
};
```

### 执行

```ts
useDidMountEffect(() => {
  // 业务的实现逻辑
}, [something]);
```

## spa 监听路由变化

如果是多页面的话，路由的变化可以被封装为一个hook

### 实现

```ts
export function useReactPath(history: H.History) {
  const [path, setPath] = useState(window.location.pathname);
  const listenToPopstate = (path: string) => {
    setPath(path);
  };

  history.listen(location => {
    listenToPopstate(location.pathname);
  });

  return path;
}
```

### 使用

```ts
const history = useHistory();
const currentPath = useReactPath(history)

useEffer(() => {
  // 当路由改变后，做出一系列的变化
}, [currentPath])
```

## useCallbackRef

用于处理子组件props传递进来的函数，
由于传入子组件的函数有可能每次都是新的，为了不一直触发render
这边用一个useRef来存和更新函数

```ts
import { useLayoutEffect, useRef } from 'react';
export const useCallbackRef = (callback: Function) => {
  const callbackRef = useRef(callback);
  useLayoutEffect(() => {
    callbackRef.current = callback;
  }, [callback])
  return callbackRef.current;
}
```

## useInView

用于感知元素是否处于屏幕内 hook

```ts
import React, { useState, useEffect, useCallback, useRef } from 'react';
import 'intersection-observer'; // polyfill

const useInView = <T extends HTMLElement = any>(
  el?: T | (() => T),
  options?: IntersectionObserverInit,
  deps: any[] = [],
  cb?: () => void,
): [React.MutableRefObject<T>, boolean] => {
  const ref = useRef<T>();
  const [inView, setInView] = useState(false);

  const callback = useCallback(
    (entries: IntersectionObserverEntry[]) => {
      setInView(entries[0].isIntersecting);
      if (entries[0].isIntersecting && cb !== undefined && typeof cb === 'function') {
        cb();
      }
    },
    [cb],
  );

  useEffect(() => {
    let target = ref.current;
    if (el) {
      // 兼容 reference 函数或者dom element
      target = typeof el === 'function' ? el() : el;
    }
    const ios = new IntersectionObserver(callback, options);
    if (target) {
      ios.observe(target);
    }
    return () => ios.disconnect();
  }, [ref.current, el, ...deps, cb]);

  return [ref as React.MutableRefObject<T>, inView];
};

export default useInView;
```

## 使用

```ts
import { useInView } from './hooks';

export default () => {
  const [ref, isInView] = useInView();

  return (
    <div ref={ref}>{isInView ? '我在屏幕内' : '我已经消失在屏幕之外了'}</div>
  )
}
```


# å…³äºtsä¸€äº›é«˜é˜¶æŠ€å·§

ts æŠ€æœ¯çš„æ–‡æ¡£å¾ˆå¤šåœ¨ç½‘ä¸Šéƒ½èƒ½æ‰¾åˆ°ï¼Œè¿™é‡Œä¸åœ¨èµ˜è¿°ï¼Œæœ¬æ–‡ä»…è®²è¿°ä¸€äº›ä½¿ç”¨ä¸Šçš„é«˜é˜¶æŠ€å·§

## inter å’Œ extends æ¡ä»¶è¯­å¥

inferï¼Œè¡¨ç¤ºåœ¨ extends æ¡ä»¶è¯­å¥ä¸­å¾…æ¨æ–­çš„ç±»å‹å˜é‡
å¯ä»¥ç”¨æ¥é€‚é…é€‚é…å‡½æ•°å¼ç¼–ç¨‹

ä¸€ä¸ªç®€å•çš„æ —å­

æˆ‘ä»¬å¯ä»¥æ¥çœ‹ä¸€ä¸ªç®€å•çš„æ —å­

```ts
type ParamType<T> = T extends (...args: any[]) => infer P ? P : T;
// æ³›å‹T èƒ½ä¸èƒ½ç»§æ‰¿ (param: infer P) => any
// å¦‚æœè¾“å…¥çš„æ³›å‹èƒ½ å±äº (param: infer P) => any çš„è¯ï¼Œ é‚£ä¹ˆ ParamType<T> = P (P æ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„å…¥å‚)
// å¦‚æœè¾“å…¥çš„æ³›å‹èƒ½ å±äº (param: infer P) => any çš„è¯ï¼Œ é‚£ä¹ˆ ParamType<T> = T

type stringTypeParam = ParamType<string>; // type stringTypeParam = string
type fuctionTypeParam = ParamType<() => boolean> // type fuctionTypeParam = boolean
```

ä¸‹é¢æ˜¯ä¸€ä¸ªè¿›é˜¶çš„æ —å­

```ts
type ParamType<T> = T extends (...args: any[]) => infer P ? P : T;

// getName æ–¹æ³•è¢«è®¾è®¡æˆå¯ä»¥æ¥æ”¶ä¸€ä¸ªå‡½æ•° æˆ–è€… æ˜¯å­—ç¬¦ä¸²

// ParamType å°†ä¼šæ ¹æ®å‡½æ•°çš„è¿”å›å€¼å¯¹æœ€ç»ˆçš„è¿”å›å€¼è¿›è¡Œå®šä¹‰
// å¦‚æœæ˜¯å‡½æ•°çš„è¯ï¼Œæˆ‘ä»¬å°±ä¼šé€šè¿‡ ParamType æ¥è·å–è¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼ çš„ç±»å‹ï¼Œå¹¶ä½œä¸º getName çš„è¿”å›å€¼è¿›è¡Œå®šä¹‰
// å¦‚æœæ˜¯å­—ç¬¦ä¸²çš„è¯ï¼Œæˆ‘ä»¬å°±ç›´æ¥æ‹¿å­—ç¬¦ä¸²è¿›è¡Œå®šä¹‰
function getName <T> (nameOrHandleName: any, name?: string) : ParamType<T> {
  if (typeof nameOrHandleName === 'function') {
      return nameOrHandleName(name);
  }

  return nameOrHandleName;
}

type addSuffixType = (name: string) => string;

// å¦‚è¿™ä¸ªæ —å­ï¼ŒaddSuffix æ˜¯æˆ‘ä»¬å®šä¹‰çš„é”™è¯¯å¤„ç†çš„å‡½æ•°ï¼Œå®ƒçš„è¿”å›å€¼æ˜¯ string 
// å› ä¸ºå…¥å‚æ˜¯ä¸ªå‡½æ•°ï¼ŒgetName è¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼å°±ä¼šæ ¹æ® addSuffix çš„è¿”å›å€¼è¿›è¡Œåˆ¤æ–­ï¼Œä¹Ÿå°±æ˜¯ infer P === string
const addSuffix: addSuffixType = (name: string) => {
  return name + '.js';
}


// æˆ‘ä»¬è¿™æ ·å°±åšåˆ°äº†ä¸€ä¸ªå¤šå‚æ§åˆ¶çš„åŠŸèƒ½
// å¦‚æœå…¥å‚æ˜¯ å¤„ç†å‡½æ•° é‚£ä¹ˆå°±æŠŠå…¥å‚çš„ name ä¸¢ç»™å¤„ç†å‡½æ•°å¤„ç†ï¼Œå¤„ç†é€»è¾‘ç”±å‡½æ•°å®šä¹‰
// å¦‚æœå…¥å‚å°±æ˜¯ä¸€ä¸ª å­—ç¬¦ä¸²name é‚£ä¹ˆå°±ç›´æ¥è¿”å›
getName<string>('script.js');
getName<addSuffixType>(addSuffix, 'script');
```

ts çš„æ–‡æ¡£ä¸­è¿˜ç»™æˆ‘ä»¬åˆ—å‡ºäº†å¾ˆå¤šå®é™…æœ‰ç”¨çš„å…³äº extends æ¡ä»¶è¯­å¥ çš„æ —å­

### æ ¹æ®ç±»å‹ï¼Œä»interface ä¸­ç­›é€‰å‡ºå±æ€§

```ts
interface Part {
  id: number;
  name: string;
  subparts: Part[];
  updatePart(newName: string): void;
  updateState(newState: object): void;
}

// è¿™ä¸ªå¯ä»¥å°† interface è½¬ä¸º è”åˆç±»å‹
type toUnionType<T> = T[keyof T];
type T38 = toUnionType<Part>;
// type T38 = string | number | Part[] | ((newName: string) => void) | ((newState: object) => void);


type FilterNonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }
/**
  { [K in keyof T]: T[K] }
  è¿™ä¸ªè¿”å›äº†ä¸€ä¸ªå¯¹è±¡ç±»å‹
  [K in keyof T] å…¶å®ä¸Šæ˜¯ è¾“å…¥çš„interfaceæ³›å‹ä¸­æ‰€æœ‰å¯¹è±¡keyçš„å¾ªç¯
  T[K] åˆ™æ˜¯å¯¹è±¡çš„value

  T[K] extends Function ? K : never
  åˆ¤æ–­è¿™ä¸ªvalueæ˜¯å¦æ˜¯ç»§æ‰¿äº Function ç±»å‹çš„ï¼Œå¦‚æœæ˜¯ åˆ™è¿”å›è¿™ä¸ª key, å¦åˆ™æ˜¯never
*/

// æˆ‘ä»¬å¯ä»¥çœ‹çœ‹ä¸Šé¢æ‰§è¡Œçš„ç»“æœï¼Œå‘ç°ä¸æ˜¯å‡½æ•°ç±»å‹çš„å­—æ®µå…¨éƒ¨ä¸ºneverï¼Œæ˜¯ Function å¯¹è±¡çš„åˆ™è‡´ä¸ºå…¶å­—æ®µ
type T39 = FilterNonFunctionPropertyNames<Part>;
// type T39 = {
//   id: never;
//   name: never;
//   subparts: never;
//   updatePart: "updatePart";
//   updateState: "updateState";
// }

// æ ¹æ®ä¸Šé¢çš„ç»“æœ, è¿™æ¡ç±»å‹å°±æ˜¯ T39[keyof T]
// ä¹Ÿå°±æ˜¯å°† interface è½¬ä¸ºäº† è”åˆç±»å‹
type FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];

// æœ€ç»ˆç»“æœT40 å°±æ˜¯ä¸€ä¸ªè”åˆç±»å‹
type T40 = FunctionPropertyNames<Part>;
// type T40 = "updatePart" | "updateState"

// æ€»çš„æ¥è¯´ï¼ŒFunctionPropertyNames å…è®¸æˆ‘ä»¬ä»ä¸€ä¸ªinterface ä¸­ç­›é€‰å‡ºæ‰€æœ‰çš„å‡½æ•°åï¼Œå¹¶è½¬ä¸ºè”åˆç±»å‹è¿”å›

// é‚£ä¹ˆåè¿‡æ¥ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡è¿™ç§æ–¹å¼æ‰¾åˆ°æ‰€æœ‰ä¸æ˜¯å‡½æ•°çš„å±æ€§å

type NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];
type T41 = NonFunctionPropertyNames<Part>;

/**
  type T41 = "id" | "name" | "subparts"
*/
```

### å¤„ç†è”åˆç±»å‹

```ts
type Exclude<T, U> = T extends U ? never : T; // ä» T ä¸­ æ‰¾ U ä¸­ä¸å­˜åœ¨çš„
type Extract<T, U> = T extends U ? T : never; // ä» T ä¸­ æ‰¾ U ä¸­å­˜åœ¨çš„
type NonNullable<T> = Exclude<T, null | undefined> // è”åˆç±»å‹ä¸­å‰”é™¤ null å’Œ undefined ç±»å‹

type T00 = Exclude<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "b" | "d"
type T01 = Extract<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "a" | "c"
```

### å¤„ç†å‡½æ•°å’Œå®ä¾‹çš„è¿”å›å€¼ç±»å‹

```ts
class Person {
  id: string;
  name: string;
  age: number;
  wannaJoinArmy: boolean;
  getFuncs: () => string;
}

type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;
// è¿™ä¸ªï¼Œå®é™…ä¸Šå’Œä¸Šæ–‡çš„ ParamType ç±»ä¼¼ï¼Œåªä¸è¿‡å¯¹äºè¿”å›ç±»å‹çš„å…œåº•ç”± T å˜ä¸ºäº† any
type InstanceType<T extends new (...args: any) => any> = T extends new (...args: any) => infer R ? R : any

class Person {
  private head = 'myHead';
  run = () => {
    console.log('I can run');
  }
};

type T20 = InstanceType<typeof Person>;  // Person
// InstanceTypeè¿”å›è¿”å›å®ä¾‹çš„æ„é€ å™¨ç±»
```

Excludeï¼ŒExtractï¼ŒNonNullableï¼ŒReturnTypeï¼ŒInstanceType éƒ½å·²ç»å†…ç½®åœ¨äº† typescript å†…

## interface å£°æ˜æ„é€ å®ä¾‹

```ts
interface PersonInstance {
  username: string;
  gender: string;

  run: () => void;
};

interface Person extends PersonInstance {
  new (username: string, gender: string): PersonInstance
}

class Person implements Person {
  constructor(username: string, gender: string) {
    this.username = username;
    this.gender = gender;
  }

  run = () => {
    console.log('I can run');
  }
}
```

## æ³›å‹ä¸­ä½¿ç”¨æ„é€ å‡½æ•°

```ts
function create <T> (c: { new(): T; }): T {
  return new c();
}
```

å’Œ interface ç±»ä¼¼ï¼ŒåŸºæœ¬éƒ½æ˜¯é€šè¿‡ new() æ¥å£°æ˜æ„é€ å¯¹è±¡çš„æ„é€ å™¨ 

## Promise ä½¿ç”¨ typescript

æ€ä¹ˆåœ¨ç”¨åˆ° promise çš„æ—¶å€™ä½¿ç”¨typescriptå‘¢ï¼Ÿ
æˆ‘ä»¬å…ˆçœ‹çœ‹ typescript å…³äº Promise çš„æ„é€ å‡½æ•°çš„å®šä¹‰

```ts
/**
* Creates a new Promise.
* @param executor A callback used to initialize the promise. This callback is passed two arguments:
* a resolve callback used resolve the promise with a value or the result of another promise,
* and a reject callback used to reject the promise with a provided reason or error.
*/
interface PromiseConstructor {

  new <T>(
    executor: (
      resolve: (value?: T | PromiseLike<T>) => void,
      reject: (reason?: any) => void
    ) => void
  ): Promise<T>

}
```

æˆ‘ä»¬å¯ä»¥å‘ç° new Promise çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å®šä¹‰æ³›å‹æˆ–è€…å®šä¹‰ resolve å‡½æ•°ï¼Œæ¥å®šä¹‰ resolve æŠ›å‡ºçš„æ•°æ®å†…å®¹ï¼š

```ts
new Promise<number>(resolve => {
  resolve(1)
})

new Promise((resolve: (value: number) => void) => {
  resolve(1)
})
```

ä¸€ä¸ªé«˜é˜¶ç‚¹çš„æ —å­
æˆ‘ä»¬å¯ä»¥çœ‹çœ‹ React-hook + typescript æ¨¡å¼ä¸‹ï¼Œå…³äºå¼‚æ­¥åŠ è½½æ•°æ®çš„å‡½æ•°å¼ç¼–ç¨‹çš„å®ç°

```ts
// æˆ‘ä»¬å¯ä»¥å£°æ˜ä¸€ä¸ª Resolve è¿™ä¸ªæ³›å‹ç”¨æ¥è·å– Promise çš„ resolve å‚æ•°çš„ç±»å‹å£°æ˜
type Resolve<T> = T extends (...args: any[]) => Promise<infer U> ? U : never;

const agent = axios.create({
  baseURL: '/',
  timeout: 10000,
  withCredentials: true
});

// æ•°æ®è¯·æ±‚å±‚
async function fetchDataes () {
  return await agent.get(REQUEST_URL);
}

// æ•°æ®å¤„ç†å±‚
async function getSomeDataes () {
  const dataes = await fetchDataes();

  // ... å¤„ç†dataes
  // å¯¹æ•°æ®è¿›è¡Œè§£æ„ï¼Œæ•°æ®è§£æ„é¢„å¤„ç†ï¼Œæ•°æ®æ ¼å¼æ ¡éªŒï¼Œç¼ºçœè¡¥å…… ç­‰ç­‰

  return result;
}

// æ•°æ®é©±åŠ¨å±‚
function afterHandleDataes <T extends (...args: any[]) => Promise<any> > ( request: T ) {
  const result: Resolve<T> = request(); // è¿™ä¸ªresult æ˜¯å¯¹äºå¼‚æ­¥å‡½æ•°è¿”å›çš„ Promise  

  // ä¹‹åå¯¹æ•°æ®çš„ç¼“å­˜æ§åˆ¶ï¼ŒuseRef æŒä¹…åŒ–ï¼Œæˆ–è€…è®¾ç½® State ç­‰ç­‰ä¸€äº›çš„å¤„ç†
  
  // è¿˜å¯ä»¥åœ¨è¿™é‡Œåšï¼Œå¼‚æ­¥æ•°æ®åŠ è½½æ€çš„å˜æ›´ï¼ˆPending or Finishï¼‰ è¿™é‡Œç®€å•çœç•¥äº†
  const [state, setState] = useState<Resolve<T>({
    ...result
  });

  const { current: ref } = useRef({
    state,

    updateState(s: Partial<Resolve<T>>) {
      setState((ref.state = { ...ref.state, ...s }))
    }
  })

  return [state, ref];
}

// è¿™æ ·å°±å®ç°äº†å¯¹äºæ•°æ®åŠ è½½çš„å‡½æ•°å¼ç¼–ç¨‹çš„è¡¨è¾¾
afterHandleDataes(getSomeDataes);
```

## å‡½æ•°é‡è½½

å€¼å¾—æ³¨æ„çš„æ˜¯ typescript å…è®¸å‡½æ•°é‡è½½ï¼Œè¿™æ˜¯ ecmascript ä¸æ”¯æŒçš„ç‰¹æ€§ï¼

```ts
function print(info: string): void;
function print(num: number): void;

print('owen');
print(100);
```

Typescript å†…éƒ¨åº“ä»£ç ï¼Œä¹Ÿç”¨äº†é‡è½½çš„ç‰¹æ€§è¿›è¡Œå°è£…

```ts
interface PromiseConstructor {
  /**
    * Creates a Promise that is resolved with an array of results when all
    * of the provided Promises resolve or reject.
    * @param values An array of Promises.
    * @returns A new Promise.
    */
  allSettled<T extends readonly unknown[] | readonly [unknown]>(values: T):
      Promise<{ -readonly [P in keyof T]: PromiseSettledResult<T[P] extends PromiseLike<infer U> ? U : T[P]> }>;

  /**
    * Creates a Promise that is resolved with an array of results when all
    * of the provided Promises resolve or reject.
    * @param values An array of Promises.
    * @returns A new Promise.
    */
  allSettled<T>(values: Iterable<T>): Promise<PromiseSettledResult<T extends PromiseLike<infer U> ? U : T>[]>;
}
// å¯ä»¥çœ‹åˆ° allSettled æ˜¯ Promise è§„èŒƒ 2020 çš„æ–°ç‰¹æ€§ ã€Promise.allSettled(promises)ã€‘
// å…¶ä¸­ ts å¯¹äº allSettled çš„å®šä¹‰ä¹Ÿæ˜¯ä½¿ç”¨äº†å‡½æ•°é‡è½½
// allSettled å…è®¸å‚æ•°ä¸ºæ•°ç»„å’Œè¿­ä»£å™¨å®ä¾‹ï¼ˆIterableï¼‰ å…¶è¿”å›çš„å€¼ä¹Ÿä¸ä¸€æ ·
```

## è·å¾— interface å†…æ‰€æœ‰å­—æ®µçš„ç±»å‹

```ts
interface Person {
  id: string;
  name: string;
  age: number;
  wannaJoinArmy: boolean;
  getFuncs: () => string;
}

type getAllTypes<T> = T[keyof T];
type T10 = getAllTypes<Person>;
/**
  type T10 = string | number | boolean | (() => string)
*/
```


## æ³›å‹çš„ç®­å¤´å‡½æ•°å†™æ³•

```ts
// æ­£å¸¸å†™æ³•
function foo <T> (x: T): T {
  return x
}

// æƒ³å½“ç„¶è§‰å¾—è¿™æ ·å¯ä»¥
const foo = <T>(x: T) => x; // ERROR : unclosed `T` tag
const foo = <T extends unknown>(x: T) => x;
```

å…¶ä¸­ extends æ˜¯å¿…é¡»çš„

å› ä¸ºå¦‚æœæ²¡æœ‰extends ç¬¦å·ï¼Œè§£é‡Šå™¨ä¼šå°†æ³›å‹Tè®¤é”™

æˆ‘ä»¬éœ€è¦é€šè¿‡ç»§æ‰¿çš„å†™æ³•æ¥hackï¼Œæé†’è§£é‡Šå™¨è¿™ä¸ªæ˜¯ä¸€ä¸ªæ³›å‹

## interface å…è®¸å¤šé‡ç»§æ‰¿

```ts
interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

let square = {} as Square;
square.color = "blue";
square.sideLength = 10;
square.penWidth = 5.0;
```

æˆ‘ä»¬å¯ä»¥çœ‹åˆ° typescript ä¸­çš„interface æ”¯æŒå¤šé‡ç»§æ‰¿ï¼Œè¿™ä¸ªä¹Ÿæ˜¯ ecmascript ä¸­ä¸æ”¯æŒçš„


## ä»¥æšä¸¾ç±»å‹ä½œä¸ºå¯¹è±¡çš„key

å‡å¦‚æˆ‘ä»¬æœ‰ä¸€ä¸ªæšä¸¾ç±»å‹

```ts
export enum TagKeys {
  'yesterday' = 1,
  'recent_7_day' = 7,
  'recent_15_day' = 15,
  'recent_30_day' = 30,
  'total' = 0
}
```

æˆ‘ç°åœ¨å¸Œæœ›å£°æ˜ä¸€ä¸ªå¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡çš„ key ä¸€å®šæ˜¯æšä¸¾ç±»å‹çš„ï¼Œå¹¶ä¸”æˆ‘å¯ä»¥é€šè¿‡æšä¸¾ç±»å‹è¿›è¡Œè®¿é—®ï¼Œä¾‹å¦‚

```ts
const map {
  map[TagKeys[1]]: 132
  map[TagKeys['recent_7_day']]: 468
}

/*
ç¼–è¯‘çš„ç»“æœï¼š
{
  'yesterday': 132,
  7: 468
}
*/
```

é‚£ä¹ˆæˆ‘ä»¬æ€ä¹ˆåšè¿™ä¸ªå¯¹è±¡çš„å£°æ˜ç±»å‹å‘¢ï¼Ÿ
é¦–å…ˆæˆ‘æƒ³åˆ°çš„æ˜¯ï¼š

```ts
type map = Record<TagKeys, number>;

/*
ä½†æ˜¯è¿™æ ·ä¼šè¢«ç¼–è¯‘æˆ
type map = {
  1: number;
  7: number;
  15: number;
  30: number;
  0: number;
}
*/
```

æ€æ ·è·å–æšä¸¾çš„åŒå‘ç»‘å®šå‘¢ï¼Ÿ

```ts
type TagKeysIndexes = keyof typeof TagKeys; // "yesterday" | "recent_7_day" | "recent_15_day" | "recent_30_day" | "total"

type map = Record<TagKeys | TagKeysIndexes, number>;
/*
type map = {
  1: number;
  7: number;
  15: number;
  30: number;
  0: number;
  yesterday: number;
  recent_7_day: number;
  recent_15_day: number;
  recent_30_day: number;
  total: number;
}
*/
```

ä¸ºä»€ä¹ˆå‘¢ï¼Œå› ä¸º ts å¤„ç†ä»¥æšä¸¾å¯¹è±¡ä¸ºç±»å‹çš„æ—¶å€™ï¼Œåªä¼šå°†æšä¸¾å¯¹è±¡çš„ values ç»‘å®šï¼Œè€Œä¸ä¼šå¤„ç† keys
æ‰€ä»¥æˆ‘ä»¬éœ€è¦æ‰‹åŠ¨å¤„ç†keysçš„ç»‘å®šå£°æ˜


æœ€åï¼Œå› ä¸ºæˆ‘ä»¬åªéœ€è¦éƒ¨åˆ†çš„å£°æ˜å€¼å°±å¤Ÿäº†ï¼Œæ‰€ä»¥æœ€åä»£ç è¿™ä¹ˆå†™
```ts
type map = Partial<Record<TagKeys | TagKeysIndexes, number>>;
/**
type map = {
  1?: number | undefined;
  7?: number | undefined;
  15?: number | undefined;
  30?: number | undefined;
  0?: number | undefined;
  yesterday?: number | undefined;
  recent_7_day?: number | undefined;
  recent_15_day?: number | undefined;
  recent_30_day?: number | undefined;
  total?: number | undefined;
}
**/
```

## hook + æ³›å‹ç»„ä»¶

```ts
// tsx å®šä¹‰æ³›å‹ç»„ä»¶
<SomeComponent<Generic>
  data={Data}
  a=1
/>

// hook å†…å£°æ˜
interface Props<T> {
  data: T[];
}

export default function <T>(props: Props<T>) {
  return (<div>{...}<div>)
};
```

é—®é¢˜æ¥äº†ï¼Œå¦‚æœæˆ‘ä»¬éœ€è¦ç”¨åˆ°React.memo ç­‰æ–¹æ³•ä½œä¸ºé«˜é˜¶ç»„ä»¶å°è£…ï¼Œæ€ä¹ˆåŠå‘¢ï¼Ÿ

è¿™æ ·å¯ä»¥è§£å†³é—®é¢˜ï¼Œä½†æ˜¯ä¸ç®—å¤ªä¼˜é›…

```ts
interface Props<T> {
  data: T[];
}

funtion Component <T>(props: Props<T>) {...}

export default React.memo(Component) as typeof Component;
```

## enum ç»§æ‰¿

å¦‚æœè¦å®ç°enumç»§æ‰¿çš„è¯ï¼Œæš‚æ—¶è¿˜åªèƒ½è¿™ä¹ˆå†™ï¼š

```ts
enum BasicEvents {
  Start = "Start",
  Finish = "Finish"
};

enum AdvEvents {
  Pause = "Pause",
  Resume = "Resume"
};

// å˜é‡ç»§æ‰¿
export const EventsVars = {...BasicEvents, ...AdvEvents};

// ç±»å‹ç»§æ‰¿
export type EventsTypes = BasicEvents | AdvEvents;
```

æœªæ¥å¯èƒ½ä¼šæ”¯æŒextends å…³é”®å­—ç›´æ¥å¤„ç†

## å¦‚ä½•æ¨æ–­ Promise çš„è¿”å›ç±»å‹

æœ‰ä¸€äº›node_modulesåº“ï¼Œå¯èƒ½ä¼šå› ä¸ºç§ç§åŸå› ï¼Œæ²¡æœ‰exportç±»å‹
æ¯”å¦‚æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼š

```ts
// æŸnode_modulesæ–‡ä»¶
import xxx from 'xxx';
// getInfo ä¼šè¿”å›Promise<InfoType>
// ä½†æ˜¯ xxx è¿™ä¸ªä¾èµ–åº“æ²¡æœ‰export InfoType ç»™æˆ‘ä»¬ï¼Œå½“æˆ‘ä»¬éœ€è¦å®šä¹‰è¿™ä¸ªInfoType çš„æ—¶å€™ï¼Œå°±éœ€è¦æ¨æ–­
xxx.getInfo
```

æˆ‘ä»¬å°è£…ä¸€ä¸ªæ–¹æ³•
```ts
export type InferPromiseReturnType<T> = T extends {
  then(onfulfilled?: (value: infer U) => unknown): unknown;
} ? U : T;
```

è¿™é‡Œä¸»è¦æ˜¯ä¾èµ– `infer` (è‹±ï¼šæ¨æ–­)è¿™ä¸ªå…³é”®å­—æ®µï¼Œ`InferPromiseReturnType` æè¿°äº†æ³›å‹Tçš„é€šç”¨ç»“æ„ï¼šç»§æ‰¿è‡ªä¸€ä¸ªå¯¹è±¡ï¼Œå®ƒæœ‰ä¸ªthenå‡½æ•°ï¼Œthenå‡½æ•°çš„è¾“å…¥æ˜¯ä¸€ä¸ª `onfulfilled` ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬å¹³æ—¶ç”¨çš„Promise.then çš„è¾“å…¥ç»“æ„

ç„¶å `InferPromiseReturnType` å°†è¿™ä¸ª value ä½œä¸ºæ³›å‹Uè¿›è¡Œæ¨æ–­ï¼Œå°†æ¨æ–­å‡ºæ¥çš„ç»“æœè¿”å›

```ts
// ç„¶åæˆ‘ä»¬å°±èƒ½é€šè¿‡è¿™æ ·æ¥è·å– InfoType
// typeof xxx.getInfo  è¿”å›  () => Promise<InfoType>: 
// ReturnType<typeof xxx.getInfo> è¿”å› Promise<InfoType>
// nferPromiseReturnType< ReturnType< typeof xxx.getInfo > > è¿”å› InfoType
type InfoType = InferPromiseReturnType< ReturnType< typeof xxx.getInfo > >
```

## å¦‚ä½•æ ¹æ®å€¼çš„ç±»å‹è¿‡æ»¤ä¸€ä¸ªæ¥å£ä¸­ç¬¦åˆè¦æ±‚çš„æ‰€æœ‰å­—æ®µï¼Ÿ

æˆ‘ä»¬æœ‰ä¸€ä¸ªBase interface

```ts
interface Child {
  d: number;
  e: string;
}

interface Base {
  a: number;
  b: string;
  c: Child;
  f: number;
  g: string;
}
```

æˆ‘ä»¬æœŸæœ›æ ¹æ®å€¼çš„ç±»å‹ï¼Œæ¥è·å–åˆ°æ‰€æœ‰ç¬¦åˆç±»å‹çš„å­—æ®µï¼Œ

```ts
type AllNumberTypeKey = FilterKeys<Base, number>; // type AllNumberTypeKey = "a" | "f"
type AllStringTypeKey = FilterKeys<Base, string>; // type AllStringTypeKey = "b" | "g"
type AllChildTypeKey = FilterKeys<Base, Child> // type AllChildTypeKey = "c"
```

FilterKeys çš„å®ç°å¦‚ä¸‹ğŸ‘‡

```ts
export type FilterKeys<S, U> = keyof {
  [K in keyof S as S[K] extends U ? K : never]: S[K];
};

// é¦–å…ˆå£°æ˜äº†ä¸€ä¸ªå¯¹è±¡ï¼Œç„¶åç”¨inéå†äº†ä¼ å…¥çš„S ä¹Ÿå°±æ˜¯ç›®æ ‡çš„interface
// æ–°å£°æ˜äº†ä¸€ä¸ªæ³›å‹K, K æ˜¯keyof Sçš„ä¾æ¬¡éå†
// åˆ¤æ–­ S[K] çš„ç±»å‹æ˜¯å¦ä¸ç›®æ ‡æ³›å‹ç›¸ç­‰ S[K] extends U, å¦‚æœç¬¦åˆå°±ä¿ç•™è¿™ä¸ªkeyï¼Œå¦‚æœä¸ç¬¦åˆå°±ä»¥ä¸€ä¸ªneveræ¥æ ‡è®°ï¼Œæ¥è¿‡æ»¤æ‰
// å°†è¿‡æ»¤å¥½åçš„Object keyof åè¿”å›
```
